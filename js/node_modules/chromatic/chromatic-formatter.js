#!/usr/bin/nodejs

var fs = require( 'fs' );
var cht  = require( 'chromatic/template' );

function init( __settings ) {
	// ScaleGenerator.voiceName = 'voice_us1_mbrola';
	function fmt( i, len ) {
		var s = String(i);
		while ( s.length < len ) {
			s ='0' + s; 
		}
		return s;
	}

	function toPDF( filename ) {
		return filename.replace( /\.ly$/, '.pdf' );
	}


	function ScaleGenerator( outputPath, filenamePrefix, templatePath ) {
		if ( ! filenamePrefix )
			filenamePrefix = ScaleGenerator.fname;
		if (! outputPath || ! filenamePrefix ) throw new Error();
		this.outputPath = outputPath;
		this.filenamePrefix = filenamePrefix;
		this.templatePath = templatePath;
		this.counter = 0;
		this.includeText = "";
		this.valueCurrentOutputFilename = "";
		this.settings = Object.assign( {}, require ( 'chromatic/settings' ), __settings );

		this.developmentMode = false;
		this.alwaysOutputHeader = false;
		this.enabled = false;
	}


	ScaleGenerator.writeFile  = function( filename, output ) {
		fs.writeFileSync( filename, output, 'utf8' );
		console.error( "generated ", filename );
	};
	ScaleGenerator.appendFile  = function( filename, output ) {
		fs.appendFileSync( filename, output, 'utf8' );
	};

	ScaleGenerator.prototype.setDevelopmentMode = function( value ) {
		this.developmentMode = value ? true : false;
	};
	ScaleGenerator.prototype.setAlwaysOutputHeader = function( value ) {
		this.alwaysOutputHeader = value ? true : false;
	};
	ScaleGenerator.prototype.enable = function() {
		this.enabled = true;
	};

	ScaleGenerator.prototype.disable = function() {
		this.enabled = false;
	};

	ScaleGenerator.prototype.nextOutputFilename = function( id ) {
		this.valueCurrentOutputFilename = this.filenamePrefix + '-' + fmt( this.counter++ ,3 ) + '-' + id + '.ly';
	};

	ScaleGenerator.prototype.currentOutputFilename = function(id) {
		return this.outputPath + this.valueCurrentOutputFilename;
	};
	ScaleGenerator.prototype.currentOutputFilenameAsPDF = function(id) {
		return toPDF( this.valueCurrentOutputFilename );
	};

	ScaleGenerator.prototype.mainOutputFilename = function() {
		return this.filenamePrefix + '-' + "output" + '.tex';
	};

	ScaleGenerator.prototype.commonOutputFilename = function(id) {
		return this.outputPath + "output.tex";
	};

	ScaleGenerator.prototype.writeIncludeText = function writeIncludeText( s ) {
		this.includeText += s;
	};

	ScaleGenerator.notes2id = function( notes ) {
		var id = notes.split( /\s+/ ).shift();
		if ( id ) 
			id.replace( /(^[a-zA-Z0-9\-_]+)(.*)$/ , (s0,s1,s2)=> s1 );
		if ( ! id  )
			throw new Error( "Invalid ID (" + id + ")" );
		return id;
	};

	/////////////////////////////////////////////////////////
	//
	// writeScore()
	//
	/////////////////////////////////////////////////////////

	/*
	 * writeScore( [id], notes, [settings] )
	 */
	var ch = require( 'chromatic' );
	function transpose( value, settings ) {
		return ch.transposeScript( value, settings ).join( " " )
	}

	function toNotes_pre( s ) {
		s = s.replace( /\n/gm, ' \\bar"" \\break ' );
		return s;
	}
	function toNotes_post( s ) {
		// console.error( s );
		s = s.replace( /\|/g,  '\\bar "|" ' );
		s = s.replace( /\n/gm, ' \\bar "" \\break ' );
		// console.error( s );
		return s;
	}
	function toNotes( s, settings ) {
		if ( ! settings  ) {
			settings = {};
		}
		s = toNotes_pre( s );
		s = transpose( s, settings );
		s = toNotes_post( s );
		return s;
	}

	ScaleGenerator.toNotes = toNotes;

	//
	// noteArrays = [
	//	  "do do re mi fa",
	//	  [ 'do', 'do', 're', 'mi', ],
	//	  [ 'do', 'do', 're', 'mi', ],
	// ] 
	// => This bocomes a file contains three scores.
	//

	ScaleGenerator.prototype.writeScore = function () {
		if ( this.developmentMode && ( ! this.enabled ) ) return;

		// var id, notes, texGraphicWidth, lyTextAfter, lyTextBefore, filter, settings;
		var id, notes, settings;
		var arr = Array.prototype.slice.call ( arguments );

		if ( arr.length == 0 ) {
			throw new Error( 'invalid argument error' );
		} else if ( arr.length == 1 ) {
			[ id, notes, settings ] = [ null , arr[0], {} ];
		} else {
			// See settings.js (Fri, 04 May 2018 17:31:07 +0900)
			[ id, notes, settings={} ] = arr;
			// console.error( 'id', id, 'notes', notes, 'texGraphicWidth ', texGraphicWidth );
		}

		var curr_settings = Object.assign( {}, this.settings, settings );

		// console.error( "curr_settings ", curr_settings );
		// console.error( "settings", settings );

		if ( id == null ) {
			// This should be / +/ not /\s+/ because \n has special meaning here.
			// See toNotes() function.
			id = notes.split( / +/ ).shift().replace( /^([^a-zA-Z0-9]*)([a-zA-Z0-9]+)([^a-zA-Z0-9]*)$/, (s0,s1,s2,s3)=> s2 );
		}

		// console.error( id );
		if ( Array.isArray( curr_settings.lyTextAfter  ) ) {
			if ( curr_settings.lyTextAfter.length == 0 ) {
				curr_settings.lyTextAfter = [5,3];
			}
			{
				let [ __h, __w ] = curr_settings.lyTextAfter;
				curr_settings.lyTextAfter = 
					`
					\\paper  {
						#(set! paper-alist (cons '("a4insides" . (cons (* ${__h} in) (* ${__w} in))) paper-alist))
						#(set-paper-size "a4insides")
					}
					`.replace(/^\t\t\t\t/,'');
			}
		}

		var output = cht.template( [ { notes : toNotes( notes, curr_settings ) } ] ,  curr_settings );

		{
			let lyTextBefore = curr_settings.eventhandler.call( 
					this, 'before', id, notes, curr_settings.lyTextBefore );
			if ( lyTextBefore )
				output = lyTextBefore + '\n\n' + output;
		}

		{
			let lyTextAfter  = curr_settings.eventhandler.call( 
					this, 'after',  id, notes, curr_settings.lyTextAfter );
			if ( lyTextAfter )
				output = output + '\n\n' + lyTextAfter + '\n';
		}

		this.nextOutputFilename( id );
		ScaleGenerator.writeFile( this.currentOutputFilename(), output );
		this.writeIncludeText(
				curr_settings.eventhandler.call( this, 'tex',id, notes, 
					'\\noindent $\\vcenter{ \\hbox{ \\includegraphics[width=' + 
					curr_settings.texGraphicWidth + 
					' \\textwidth]{' + 
					this.currentOutputFilenameAsPDF() + 
					'}}}$\n' ));
	};

	function caption2id( caption ) {
		var id = caption.replace( /[^a-zA-Z0-9]/g, "" );
		// Limit the maximum length of id
		if ( 24 < id.length )
			id = id.substring(0,24);
		return id;
	};
	ScaleGenerator.caption2id = caption2id;

	ScaleGenerator.prototype.writeHeaderVoice = function( caption ) {
		var id = "Header" + caption2id( caption );
		this.nextOutputFilename( id );
		var filename = this.currentOutputFilename();

		ScaleGenerator.writeFile( filename + ".ftxt", caption );

		// fs.writeFileSync( filename + ".ftxt" , caption , 'utf8' );
		// require('child_process').execSync( 'text2wave -eval "(' + ScaleGenerator.voiceName + ')" ' + filename + ".ftxt" + '>' + filename + ".wav" );
	}

	ScaleGenerator.prototype.writeAbstract = function(caption) {
		if ( this.developmentMode && ( ! this.alwaysOutputHeader ) && ( ! this.enabled ) ) return;
		var filtered  = this.settings.festivalFilter( 'header-1', caption );
		this.writeHeaderVoice( filtered.festival );
		this.writeIncludeText('\\begin{abstract}' + filtered.caption + '\\end{abstract}\n' );
	};
	ScaleGenerator.prototype.writeHeaderPart = function(caption) {
		if ( this.developmentMode && ( ! this.alwaysOutputHeader ) && ( ! this.enabled ) ) return;
		var filtered  = this.settings.festivalFilter( 'header-1', caption );
		this.writeHeaderVoice( filtered.festival );
		this.writeIncludeText('\\part{' + filtered.caption + '}\n' );
	};
	ScaleGenerator.prototype.writeHeader0 = function(caption) {
		if ( this.developmentMode && ( ! this.alwaysOutputHeader ) && ( ! this.enabled ) ) return;
		var filtered  = this.settings.festivalFilter( 'header0', caption );
		this.writeHeaderVoice( filtered.festival );
		this.writeIncludeText('\\section{' + filtered.caption + '}\n' );
	};

	ScaleGenerator.prototype.writeHeader1 = function(caption) {
		if ( this.developmentMode && ( ! this.alwaysOutputHeader ) && ( ! this.enabled ) ) return;
		var filtered  = this.settings.festivalFilter( 'header1', caption );
		this.writeHeaderVoice( filtered.festival );
		this.writeIncludeText('\\subsection{' + filtered.caption + '}\n' );
	};

	ScaleGenerator.prototype.writeHeader2 = function(caption) {
		if ( this.developmentMode && ( ! this.alwaysOutputHeader ) && ( ! this.enabled ) ) return;
		var filtered  = this.settings.festivalFilter( 'header2', caption );
		this.writeHeaderVoice( filtered.festival );
		this.writeIncludeText( '\\subsubsection{' + filtered.caption + '}\n' );
	};
	ScaleGenerator.prototype.writeHeader3 = function(caption) {
		if ( this.developmentMode && ( ! this.alwaysOutputHeader ) && ( ! this.enabled ) ) return;
		var filtered  = this.settings.festivalFilter( 'header3', caption );
		this.writeHeaderVoice( filtered.festival );
		this.writeIncludeText( '\\paragraph{' + filtered.caption + '}\n' );
	};

	ScaleGenerator.prototype.writeTextBody = function(caption) {
		if ( this.developmentMode && ( ! this.alwaysOutputHeader ) && ( ! this.enabled ) ) return;
		var filtered  = this.settings.festivalFilter(  'body', caption );
		this.writeHeaderVoice( filtered.festival );
		this.writeIncludeText( '' + filtered.caption + '\n\n' );
	};

	// writeCommand() outputs only tex commands but does not output festival commands.
	ScaleGenerator.prototype.writeCommands = function( commands ) {
		if ( this.developmentMode && ( ! this.alwaysOutputHeader ) && ( ! this.enabled ) ) return;
		this.writeIncludeText( '' +  commands  + '\n\n' );
	};
	ScaleGenerator.prototype.writeTOC = function() {
		this.writeCommands( "\\tableofcontents" );
	};
	ScaleGenerator.prototype.writeNewPage = function() {
		this.writeCommands( "~\\newpage" );
	};
	function makeTagFunction( func ) {
		return function ( tag ) {
			func.call( this, String.raw( tag ) );
		};
	}

	ScaleGenerator.prototype.t_abstract   = makeTagFunction( ScaleGenerator.prototype.writeAbstract   );
	ScaleGenerator.prototype.t_headerPart = makeTagFunction( ScaleGenerator.prototype.writeHeaderPart );
	ScaleGenerator.prototype.t_header0    = makeTagFunction( ScaleGenerator.prototype.writeHeader0    );
	ScaleGenerator.prototype.t_header1    = makeTagFunction( ScaleGenerator.prototype.writeHeader1    );
	ScaleGenerator.prototype.t_header2    = makeTagFunction( ScaleGenerator.prototype.writeHeader2    );
	ScaleGenerator.prototype.t_header3    = makeTagFunction( ScaleGenerator.prototype.writeHeader3    );
	ScaleGenerator.prototype.t_textBody   = makeTagFunction( ScaleGenerator.prototype.writeTextBody   );
	ScaleGenerator.prototype.t_commands   = makeTagFunction( ScaleGenerator.prototype.writeCommands   );



	ScaleGenerator.prototype.close = function(caption) {
		// Output to their main file.
		ScaleGenerator.writeFile( this.outputPath + this.mainOutputFilename(), this.includeText );

		// // Output to the common main file.
		// var commonOutput = `\\input{ ly-generated/${ this.mainOutputFilename() } }`;
		// ScaleGenerator.appendFile( this.commonOutputFilename() , commonOutput );
		// console.error( commonOutput );
	};

	ScaleGenerator.note2festival_map = [
			{ note : "de"   , festival : "daeh"   },
			{ note : "do"   , festival : "doh"    },
			{ note : "di"   , festival : "dee"    },
			{ note : "ra"   , festival : "rah"    },
			{ note : "re"   , festival : "ray"    },
			{ note : "ri"   , festival : "ree"    },
			{ note : "me"   , festival : "meh"    },
			{ note : "mi"   , festival : "mee"    },
			{ note : "ma"   , festival : "mah"    },
			{ note : "fe"   , festival : "feh"    },
			{ note : "fa"   , festival : "faah"   },
			{ note : "fi"   , festival : "fee"    },
			{ note : "se"   , festival : "saeh"   },
			{ note : "sol"  , festival : "sew"    },
			{ note : "si"   , festival : "see"    },
			{ note : "le"   , festival : "laeh"   },
			{ note : "la"   , festival : "lah"    },
			{ note : "li"   , festival : "lee"    },
			{ note : "te"   , festival : "taeh"   },
			{ note : "ti"   , festival : "tee"    },
			{ note : "ta"   , festival : "taah"   },
	
			{ note : "daw"  , festival : "daw"    },
			{ note : "raw"  , festival : "raw"    },
			{ note : "maw"  , festival : "maw"    },
			{ note : "faw"  , festival : "faw"    },
			{ note : "saw"  , festival : "saw"    },
			{ note : "law"  , festival : "law"    },
			{ note : "taw"  , festival : "taw"    },
	
			{ note : "dai"  , festival : "dai"    },
			{ note : "rai"  , festival : "rai"    },
			{ note : "mai"  , festival : "mai"    },
			{ note : "fai"  , festival : "fai"    },
			{ note : "sai"  , festival : "sai"    },
			{ note : "lai"  , festival : "lai"    },
			{ note : "tai"  , festival : "tai"    },
	
			{ note : "dae"  , festival : "dae"    },
			{ note : "rae"  , festival : "rae"    },
			{ note : "mae"  , festival : "mae"    },
			{ note : "fae"  , festival : "fae"    },
			{ note : "sae"  , festival : "sae"    },
			{ note : "lae"  , festival : "lae"    },
			{ note : "tae"  , festival : "tae"    },
	
			{ note : "dao"  , festival : "dao"    },
			{ note : "rao"  , festival : "rao"    },
			{ note : "mao"  , festival : "mao"    },
			{ note : "fao"  , festival : "fao"    },
			{ note : "sao"  , festival : "sao"    },
			{ note : "lao"  , festival : "lao"    },
			{ note : "tao"  , festival : "tao"    },
	
			{ note : "daes" , festival : "daes"   },
			{ note : "raes" , festival : "raes"   },
			{ note : "maes" , festival : "maes"   },
			{ note : "faes" , festival : "faes"   },
			{ note : "saes" , festival : "saes"   },
			{ note : "laes" , festival : "laes"   },
			{ note : "taes" , festival : "taes"   },
	
			{ note : "daos" , festival : "daos"   },
			{ note : "raos" , festival : "raos"   },
			{ note : "maos" , festival : "maos"   },
			{ note : "faos" , festival : "faos"   },
			{ note : "saos" , festival : "saos"   },
			{ note : "laos" , festival : "laos"   },
			{ note : "taos" , festival : "taos"   },
		];

	// NOT USED (Tue, 29 May 2018 05:48:36 +0900)
	ScaleGenerator.note2festival = function ( note ) {
		for ( var i=0; i<ScaleGenerator.note2festival_map.length; i++ ) {
			var obj = ScaleGenerator.note2festival_map[i]
			if ( obj.note == note  ) {
				return obj.festival;
			}
		}
		throw new Error( note + ' is not a valid note name.' );
	};

	// NOT USED (Tue, 29 May 2018 05:48:36 +0900)
	ScaleGenerator.replace_note2festival = function ( str ) {
		for ( var i=0; i<ScaleGenerator.note2festival_map.length; i++ ) {
			var obj = ScaleGenerator.note2festival_map[i]
			str = str.replace( new RegExp( `\\b${obj.note}\\b` , 'g' ), obj.festival  );
		}
		return str;
	};


	/*
	 * filtered = {
	 *     festival : "string",
	 *     caption  : "string",
	 * };
	 */
	// default function for settings.festivalFilter
	ScaleGenerator.defaultFestivalFilter = function ( type, caption ) {
		function caption2festival( type, caption ) {
			var filecontent = caption;

			// Replace tex command to plain text.
			// filecontent = filecontent.replace( /\\[a-zA-Z]+\{([^\u007d]*)\}/g, (s0,s1)=>`"${s1}"` );
			filecontent= filecontent.replace( /\\[a-zA-Z ]+\{([^\u007f]*?)\}/g, (s0,s1,s2)=>`${s1}` );
			filecontent= filecontent.replace( /\\([a-zA-Z]+)/g, (s0,s1)=>`${s1}` );



			filecontent = filecontent.replace( /\[([a-zA-Z0-9\s]+)\]/g , 
					(s0,s1)=>s1.replace( /([a-zA-Z]+)/g, 
						(s0,s1)=> ScaleGenerator.note2festival( s1.trim() ) ) );

			// Place a period at the end if there is none.
			if ( ! /\.$/.exec( filecontent ) )
				filecontent = filecontent + '.';

			return filecontent;
		};

		// Remove extended local festival commands which are special for "chromatic-formatter.js".
		function caption2caption( type, caption ) {
			// Extract note name from do-re-mi command. (Tue, 29 May 2018 05:21:15 +0900)
			caption = caption.replace( /\[([a-zA-Z0-9\s]+)\]/g , (s0,s1)=>s1 );

			return caption;
		}

		return {
			caption  : caption2caption(  type, caption ),
			festival : caption2festival( type, caption ),
		};
	};

	Object.defineProperty( ScaleGenerator, 'fname', {
		configurable:false,
		get() { return process.argv[1] ? require( 'path' ).basename( process.argv[1] ) : 'default' },
		set() {}
	})

	// not used ... maybe
	function commandInterface() {
		var args = Array.prototype.slice.call( process.argv );
		args.shift();
		args.shift();
		var notes = args.join( ' ' );
		// console.error( notes );
		process.stdout.write( cht.template( [ { notes : toNotes( notes ) } ] , this.settings ) );
		process.stdout.write( "\n" );

		// let content = '';
		// process.stdin.resume();
		// process.stdin.on('data', function(buf) { content += buf.toString(); });
		// process.stdin.on('end', function() {
		// });
	}
	ScaleGenerator.commandInterface = commandInterface;

	ScaleGenerator.init = init;

	return ScaleGenerator;
}

if ( module && module.exports ) {
	module.exports = init();
} 

if ( require.main === module ) {
	commandInterface();
}



// vim: filetype=javascript :

