#!/usr/bin/nodejs

var ch = require( 'chromatic' );
var fs = require( 'fs' );
var template  = require( 'solfege-template' );

function transpose( value ) {
	return ch.transpose( value ).join( " " )
}

function toNotes( s ) {
	s = s.replace( '|', '\\bar "|" ' );
	s = s.replace( /\n/, ' \\bar "" \\break ' );
	return s;
}
function toLyrics( s ) {
	// Removing 's'
	s = s.replace( /(\s*\bs[0-9]*\b\s*)/g, ' ' );
	// Replacing ' ,
	s = s.replace( /[\'\,]/g, " " );
	// Replacing '< ... >'
	s = s.replace( /\<(.*?)\>/g, ( s0, s1 ) => {
		s1 = s1.split( / +/ ).reverse().join( " " ).trim();
		return "\\markup{   \\override #\'(baseline-skip . 2.5) \\center-column{ " + s1 + "  } } " 
	});
	// Replacing '[ ... ]'
	s = s.replace( /[\[\]]/g, " " );
	return s;
}
function fmt( i, len ) {
	var s = String(i);
	while ( s.length < len ) {
		s ='0' + s; 
	}
	return s;
}

function toPDF( filename ) {
	return filename.replace( /\.ly$/, '.pdf' );
}


function ScaleGenerator( outputPath, filenamePrefix, templatePath ) {
	if ( ! filenamePrefix )
		filenamePrefix = ScaleGenerator.fname;
	if (! outputPath || ! filenamePrefix ) throw new Error();
	this.outputPath = outputPath;
	this.filenamePrefix = filenamePrefix;
	this.templatePath = templatePath;
	this.counter = 0;
	this.includeText = "";
	this.valueCurrentOutputFilename = "";
}

//
// noteArrays = [
//	  "do do re mi fa",
//	  [ 'do', 'do', 're', 'mi', ],
//	  [ 'do', 'do', 're', 'mi', ],
// ] 
// => This bocomes a file contains three scores.
//
ScaleGenerator.applyTemplate =  function applyTemplate( noteArrays, sourceFilename, templatePath ) {
	// Note : note that templatePath can be undefined. See solfege-template.ly .
	if ( Array.isArray( noteArrays ) ) {
		throw new Error( "Passing an array object here is not implemented. See tag LATE_GEN_2018." );
	} else {
		noteArrays = [ noteArrays ] ;
	}

	/*
	 * LATE_GEN_2018
	 * 
	 * WARNING noteArrays CANNOT ACCEPT ARRAYS ANYMORE.
	 *
	 * This modification (LATE_GEN_2018) breaks the specification that
	 * applyTemplate() function accepts noteArrays as an array object so that
	 * the multiple series of notes can be processed. This functionality is not
	 * used. If you are planning to use this functionality, this implementation
	 * must be re-implemented.
	 */

	var result = [];
	for ( var i=0; i< noteArrays.length; i++ ) {
		var s = transpose( noteArrays[i] );

		// console.error( s );
		// console.error( toNotes( s ) ) ;
		// console.error( toLyrics( s ) ) ;
		result[i] = {
			filename : sourceFilename, // LATE_GEN_2018
			notes : toNotes( s ),
			lyrics : toLyrics( s  ),
		};
	}
	return template( result, null, templatePath );
};

ScaleGenerator.writeFile  = function( filename, output ) {
	fs.writeFileSync( filename, output, 'utf8' );
	console.error( "generated ", filename );
};
ScaleGenerator.appendFile  = function( filename, output ) {
	fs.appendFileSync( filename, output, 'utf8' );
};


ScaleGenerator.prototype.nextOutputFilename = function( id ) {
	this.valueCurrentOutputFilename = this.filenamePrefix + '-' + fmt( this.counter++ ,3 ) + '-' + id + '.ly';
};

ScaleGenerator.prototype.currentOutputFilename = function(id) {
	return this.outputPath + this.valueCurrentOutputFilename;
};
ScaleGenerator.prototype.currentOutputFilenameAsPDF = function(id) {
	return toPDF( this.valueCurrentOutputFilename );
};

ScaleGenerator.prototype.mainOutputFilename = function() {
	return this.filenamePrefix + '-' + "output" + '.tex';
};

ScaleGenerator.prototype.commonOutputFilename = function(id) {
	return this.outputPath + "output.tex";
};

ScaleGenerator.prototype.writeIncludeText = function writeIncludeText( s ) {
	this.includeText += s;
};

ScaleGenerator.notes2id = function( notes ) {
	var id = notes.split( /\s+/ ).shift();
	if ( id ) 
		id.replace( /(^[a-zA-Z0-9\-_]+)(.*)$/ , (s0,s1,s2)=> s1 );
	if ( ! id  )
		throw new Error( "Invalid ID (" + id + ")" );
	return id;
};


ScaleGenerator.prototype.writeScore = function () {
	var type, notes, textAfter, textBefore;
	var arr = Array.prototype.slice.call ( arguments );
	if ( arr.length == 0 ) {
		throw new Error( 'invalid argument error' );
	} else if ( arr.length == 1 ) {
		[ type, notes, size, textAfter, textBefore ] = [ null, arr[0], undefined, undefined, undefined ];
	} else {
		[ type, notes, size=null, textAfter=null, textBefore=null ] = arr;
	}

	var id;
	if ( type == null ) {
		// This should be / +/ not /\s+/ because \n has special meaning here.
		// See toNotes() function.
		id = notes.split( / +/ ).shift();
		// id = notes.split( /\s+/ ).shift();
		id = id.replace( /^([^@]+)(.*)$/, (s0,s1,s2)=> s1 );
	} else {
		id = type;
	}
	// console.error( id );
	//
	if ( Array.isArray( textAfter  ) ) {
		if ( textAfter.length == 0 ) {
			textAfter = [5,3];
		}
		{
			let [ __h, __w ] = textAfter;
			var textAfter = 
				`
				\\paper  {
					#(set! paper-alist (cons '("a4insides" . (cons (* ${__h} in) (* ${__w} in))) paper-alist))
					#(set-paper-size "a4insides")
				}
				`.replace(/^\t\t\t\t/,'');
		}
	}


	this.nextOutputFilename( id );

	var output = ScaleGenerator.applyTemplate( notes,  this.valueCurrentOutputFilename , this.templatePath );

	if ( textBefore )
		output = textBefore + '\n\n' + output;
	if ( textAfter )
		output = output + '\n\n' + textAfter + '\n';
	if ( ! size ) 
		size = '1.0';

	ScaleGenerator.writeFile( this.currentOutputFilename(), output );
	this.writeIncludeText( '\\noindent $\\vcenter{ \\hbox{ \\includegraphics[width='+size+' \\textwidth]{' + this.currentOutputFilenameAsPDF() + '}}}$\n' );
};
ScaleGenerator.prototype.writeHeaderVoice = function( caption ) {
	var id = caption.replace( /[^a-zA-Z0-9]/g, "" );
	// Limit the maximum length of id
	if ( 24 < id.length )
		id = id.substring(0,24);
	id = "Header" + id ;

	this.nextOutputFilename( id );

	var filename = this.currentOutputFilename();
	var filecontent =  caption

	// Replace tex command to plain text.
	filecontent = filecontent.replace( /\\[a-zA-Z]+{([a-zA-Z0-9\s]*)}/g, (s0,s1)=>s1 );

	// Place a period at the end if there is none.
	if ( ! /\.$/.exec( filecontent ) )
		filecontent = filecontent + '.';

	fs.writeFileSync( filename + ".txt" , filecontent , 'utf8' );

	require('child_process').execSync( 'text2wave -eval "(voice_us1_mbrola)" ' + filename + ".txt" + '>' + filename + ".wav" );
}

ScaleGenerator.prototype.writeHeader0 = function(caption) {
	this.writeHeaderVoice( caption );
	this.writeIncludeText('\\section{' + caption + '}\n' );
};

ScaleGenerator.prototype.writeHeader1 = function(caption) {
	this.writeHeaderVoice( caption );
	this.writeIncludeText('\\subsection{' + caption + '}\n' );
};

ScaleGenerator.prototype.writeHeader2 = function(caption) {
	this.writeHeaderVoice( caption );
	this.writeIncludeText( '\\subsubsection{' + caption + '}\n' );
};
ScaleGenerator.prototype.writeHeader3 = function(caption) {
	this.writeHeaderVoice( caption );
	this.writeIncludeText( '\\paragraph{' + caption + '}\n' );
};

ScaleGenerator.prototype.writeTextBody = function(caption) {
	this.writeHeaderVoice( caption );
	this.writeIncludeText( '' + caption + '\n\n' );
};
ScaleGenerator.prototype.close = function(caption) {
	// Output to their main file.
	ScaleGenerator.writeFile( this.outputPath + this.mainOutputFilename(), this.includeText );

	// // Output to the common main file.
	// var commonOutput = `\\input{ ly-generated/${ this.mainOutputFilename() } }`;
	// ScaleGenerator.appendFile( this.commonOutputFilename() , commonOutput );
	// console.error( commonOutput );
};


Object.defineProperty( ScaleGenerator, 'fname', {
	configurable:false,
	get() { return process.argv[1] ? require( 'path' ).basename( process.argv[1] ) : 'default' },
	set() {}
})

function commandInterface() {
	var args = Array.prototype.slice.call( process.argv );
	args.shift();
	args.shift();
	var notes = args.join( ' ' );
	console.error( notes );
	process.stdout.write( ScaleGenerator.applyTemplate( notes ) );
	process.stdout.write( "\n" );

	// let content = '';
	// process.stdin.resume();
	// process.stdin.on('data', function(buf) { content += buf.toString(); });
	// process.stdin.on('end', function() {
	// });
}
ScaleGenerator.commandInterface = commandInterface;

if ( module && module.exports ) {
	module.exports = ScaleGenerator;
} 

if ( require.main === module ) {
	commandInterface();
}



// vim: filetype=javascript :

